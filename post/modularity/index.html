<!doctype html><html lang=en itemscope itemtype=http://schema.org/WebPage><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><title>Modularity and Paradigms - Felix' Programming Blog</title><meta name=description content="Scala is a great multi-paradigm programming language, but what's in a paradigm?

Paradigm: a world view underlying the theories and methodology of a particular scientific subject.

If a paradigm is a world view, it should encompass everything about a specific programming language. Programming languages that hail from academia tend to be very true to the underlying model of computation, casting all language constructs in the light of that model."><meta name=author content="Felix Bj√¶rt Hargreaves"><script type=application/ld+json>{"@context":"http://schema.org","@type":"WebSite","name":"Felix\x27 Programming Blog","url":"https:\/\/hejfelix.github.io\/blog\/"}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"Organization","name":"","url":"https:\/\/hejfelix.github.io\/blog\/"}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"https:\/\/hejfelix.github.io\/blog\/","name":"home"}},{"@type":"ListItem","position":3,"item":{"@id":"https:\/\/hejfelix.github.io\/blog\/post\/modularity\/","name":"Modularity and paradigms"}}]}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","author":{"name":"Felix Bj√¶rt Hargreaves"},"headline":"Modularity and Paradigms","description":"Scala is a great multi-paradigm programming language, but what\x27s in a paradigm?\n Paradigm: a world view underlying the theories and methodology of a particular scientific subject.\n If a paradigm is a world view, it should encompass everything about a specific programming language. Programming languages that hail from academia tend to be very true to the underlying model of computation, casting all language constructs in the light of that model.\n","inLanguage":"en","wordCount":2236,"datePublished":"2020-03-06T14:37:00","dateModified":"2020-03-06T14:37:00","image":"https:\/\/hejfelix.github.io\/blog\/images\/avatar_square.jpg","keywords":[""],"mainEntityOfPage":"https:\/\/hejfelix.github.io\/blog\/post\/modularity\/","publisher":{"@type":"Organization","name":"https:\/\/hejfelix.github.io\/blog\/","logo":{"@type":"ImageObject","url":"https:\/\/hejfelix.github.io\/blog\/images\/avatar_square.jpg","height":60,"width":60}}}</script><meta property="og:title" content="Modularity and Paradigms"><meta property="og:description" content="Scala is a great multi-paradigm programming language, but what's in a paradigm?

Paradigm: a world view underlying the theories and methodology of a particular scientific subject.

If a paradigm is a world view, it should encompass everything about a specific programming language. Programming languages that hail from academia tend to be very true to the underlying model of computation, casting all language constructs in the light of that model."><meta property="og:image" content="https://hejfelix.github.io/blog/images/avatar_square.jpg"><meta property="og:url" content="https://hejfelix.github.io/blog/post/modularity/"><meta property="og:type" content="website"><meta property="og:site_name" content="Felix' Programming Blog"><meta name=twitter:title content="Modularity and Paradigms"><meta name=twitter:description content="Scala is a great multi-paradigm programming language, but what's in a paradigm?

Paradigm: a world view underlying the theories and methodology of a particular scientific subject.

If a paradigm is a ‚Ä¶"><meta name=twitter:image content="https://hejfelix.github.io/blog/images/avatar_square.jpg"><meta name=twitter:card content="summary"><meta name=twitter:site content="@FelixHargreaves"><meta name=twitter:creator content="@FelixHargreaves"><meta name=generator content="Hugo 0.61.0"><link rel=alternate href=https://hejfelix.github.io/blog/index.xml type=application/rss+xml title="Felix' Programming Blog"><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css integrity=sha384-9eLZqc9ds8eNjO3TmqPeYcDj8n+Qfa4nuSiGYa6DjLNcv9BtN69ZIulL9+8CqC9Y crossorigin=anonymous><link rel=stylesheet href=https://use.fontawesome.com/releases/v5.5.0/css/all.css integrity=sha384-B4dIYHKNBt8Bc12p+WXckhzcICo0wtJAoU8YZTY5qE0Id1GSseTk6S+L3BlXeVIU crossorigin=anonymous><link rel=stylesheet href=https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css integrity=sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u crossorigin=anonymous><link rel=stylesheet href=https://hejfelix.github.io/blog/css/main.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic"><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Merriweather:300,300i,700,700i"><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800"><link rel=stylesheet href=https://hejfelix.github.io/blog/css/syntax.css><link rel=stylesheet href=https://hejfelix.github.io/blog/css/codeblock.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe.min.css integrity=sha384-h/L2W9KefUClHWaty3SLE5F/qvc4djlyR4qY3NUV5HGQBBW7stbcfff1+I/vmsHh crossorigin=anonymous><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/default-skin/default-skin.min.css integrity=sha384-iD0dNku6PYSIQLyfTOpB06F2KCZJAKLOThS5HRe8b3ibhdEQ6eKsFf/EeFxdOt5R crossorigin=anonymous><script type=text/javascript async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">MathJax.Hub.Config({tex2jax:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$']],processEscapes:true,processEnvironments:true,skipTags:['script','noscript','style','textarea','pre'],TeX:{equationNumbers:{autoNumber:"AMS"},extensions:["AMSmath.js","AMSsymbols.js"]}}});MathJax.Hub.Queue(function(){var all=MathJax.Hub.getAllJax(),i;for(i=0;i<all.length;i+=1){all[i].SourceElement().parentNode.className+=' has-jax';}});MathJax.Hub.Config({TeX:{equationNumbers:{autoNumber:"AMS"}}});</script></head><body><nav class="navbar navbar-default navbar-fixed-top navbar-custom"><div class=container-fluid><div class=navbar-header><button type=button class=navbar-toggle data-toggle=collapse data-target=#main-navbar>
<span class=sr-only>Toggle navigation</span>
<span class=icon-bar></span><span class=icon-bar></span><span class=icon-bar></span></button>
<a class=navbar-brand href=https://hejfelix.github.io/blog/>Felix' Programming Blog</a></div><div class="collapse navbar-collapse" id=main-navbar><ul class="nav navbar-nav navbar-right"></ul></div><div class=avatar-container><div class=avatar-img-border><a title="Felix' Programming Blog" href=https://hejfelix.github.io/blog/><img class=avatar-img src=https://hejfelix.github.io/blog/images/avatar_square.jpg alt="Felix' Programming Blog"></a></div></div></div></nav><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><header class=header-section><div class="intro-header no-img"><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class=post-heading><h1>Modularity and Paradigms</h1><span class=post-meta><i class="fas fa-calendar"></i>&nbsp;Posted on March 6, 2020
&nbsp;|&nbsp;<i class="fas fa-clock"></i>&nbsp;11&nbsp;minutes
&nbsp;|&nbsp;<i class="fas fa-user"></i>&nbsp;Felix Bj√¶rt Hargreaves</span></div></div></div></div></div></header><div class=container role=main><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><article role=main class=blog-post><p><strong>Scala</strong> is a great <em>multi-paradigm</em> programming language, but what's in a <em>paradigm</em>?</p><blockquote><p><strong>Paradigm</strong>: <em>a world view underlying the theories and methodology of a particular scientific subject.</em></p></blockquote><p>If a paradigm is a <strong>world view</strong>, it should encompass everything about a specific programming language. Programming languages that hail from academia tend to be very true to the underlying model of computation, casting all language constructs in the light of that model.</p><p><img src=/blog/images/bill_nye.webp alt="Bill nye"></p><h1 id=haskell>Haskell</h1><p><strong>Haskell</strong> is a good example of a language where both syntax and language constructs are clearly based on the lambda calculus. Function application is denoted simply by arranging the function and arguments next to each other:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#000>f</span> <span style=color:#000>x</span>
</code></pre></div><p>where <code>f</code> is a function, and <code>x</code> is an argument to which <code>f</code> is applied.
In the lambda calculus, function application uses the exact same notation:</p><blockquote><p>$ f x $</p></blockquote><p>In Haskell, function literals are defined by backslashes:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#000;font-weight:700>(</span><span style=color:#000>\</span><span style=color:#000>x</span> <span style=color:#204a87;font-weight:700>-&gt;</span> <span style=color:#000;font-weight:700>(</span><span style=color:#ce5c00;font-weight:700>+</span><span style=color:#000;font-weight:700>)</span> <span style=color:#000>x</span> <span style=color:#000>x</span><span style=color:#000;font-weight:700>)</span> <span style=color:#0000cf;font-weight:700>21</span>
<span style=color:#8f5902;font-style:italic>-- 42</span>
</code></pre></div><p>the reasoning behind the backslash is that it <em>&ldquo;kinda looks like half-a-lambda symbol&rdquo;</em>. (The $\lambda$ symbol is also nowhere to be found on most keyboards). Consider the corresponding notation in lambda calculus:</p><blockquote><p>$ \lambda x . + x x $</p></blockquote><blockquote><p><strong>NOTE</strong>: <code>+</code> is not a part of the lambda calculus, we just use it as a placeholder for a function that implements addition. <strong>The same goes for integer literals.</strong></p></blockquote><h2 id=currying>Currying</h2><p>This leads us to another feature of Haskell, namely <strong>currying</strong> by default. In the lambda calculus, there are only functions of 0 arguments (constants) and functions of 1 argument. How does addition work, then? It clearly needs 2 operands. The <code>(+)</code> function takes a single number and yields a function which &ldquo;stores&rdquo; this first argument. The new function can only add to this number, i.e., the first argument is considered a constant at this point.</p><blockquote><p>$$ (+) = \lambda x . \lambda y . \mathtt{builtin (x,y)} $$</p></blockquote><blockquote><p>\begin{align}
&(+) \; 39 \; 3
\\ =\; &(\lambda x . \lambda y . \mathtt{builtin (x,y)} ) \; 39 \; 3 \<br>\\ =\; &(\lambda y . \mathtt{builtin (39,y)} ) \; 3
\\ =\; & \mathtt{builtin (39,3)}
\end{align}</p></blockquote><p><code>builtin</code> can then be calculated using the instructions and integers of the CPU on the current platform. It <em>is</em> possible to encode integers and addition in the pure lambda calculus, but it gets hairy very quickly, and it's a good place to <em>draw the line between theory and pragmatism</em>.</p><h2 id=functions>Functions</h2><p>A function definition in <strong>Haskell</strong> is a bit of syntax sugar for the lambda calculus. A straight forward function definition could look like so:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#000>addmul</span> <span style=color:#000>x</span> <span style=color:#000>y</span> <span style=color:#204a87;font-weight:700>=</span> <span style=color:#000>x</span> <span style=color:#ce5c00;font-weight:700>+</span> <span style=color:#000;font-weight:700>(</span><span style=color:#000>x</span> <span style=color:#ce5c00;font-weight:700>*</span> <span style=color:#000>y</span><span style=color:#000;font-weight:700>)</span>
</code></pre></div><p>but it could also be with prefix notation as such:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#000>addmul</span> <span style=color:#000>x</span> <span style=color:#000>y</span> <span style=color:#204a87;font-weight:700>=</span> <span style=color:#000;font-weight:700>(</span><span style=color:#ce5c00;font-weight:700>+</span><span style=color:#000;font-weight:700>)</span> <span style=color:#000>x</span> <span style=color:#000;font-weight:700>(</span><span style=color:#000;font-weight:700>(</span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000;font-weight:700>)</span> <span style=color:#000>x</span> <span style=color:#000>y</span><span style=color:#000;font-weight:700>)</span>
</code></pre></div><p>we can then desugar that as:</p><blockquote><p>$$ addmul = \lambda x . \lambda y . + x \; (* \; x \; y) $$</p></blockquote><p>Since the lambda calculus doesn't include the (=) equality term, we can bind our function as an argument to the rest of the program like so:</p><blockquote><p>$$ (\lambda addmul . \; \mathbb{P}) (\lambda x . \; \lambda y . + \; x \; (* \; x \; y)) $$</p></blockquote><p>where $\mathbb{P}$ is &ldquo;the rest of our program&rdquo;, now with the definition of <code>addmul</code> in scope.</p><p>The point here is that, with relatively few (and easy) transformations, we have desugared the haskell code into a program in the lambda calculus. You could say that the paradigm of <code>functional programming</code> is based on lambda calculus.</p><h1 id=logic-programming>Logic Programming</h1><p><strong>Prolog</strong> is another example of a language where the syntax is heavily influenced by the underlying paradigm: <strong>logic programming</strong>. It consists of rules (&ldquo;entailments&rdquo;), and facts.</p><p>Rules use the <em>entailment</em> <strong>( $\vdash$ )</strong> symbol written in ASCII as:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-prolog data-lang=prolog><span style=color:#000>disney</span> <span style=color:#ce5c00;font-weight:700>:-</span> <span style=color:#000>dog</span><span style=color:#000;font-weight:700>(</span><span style=color:#4e9a06>goofy</span><span style=color:#000;font-weight:700>)</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>mouse</span><span style=color:#000;font-weight:700>(</span><span style=color:#4e9a06>mickey</span><span style=color:#000;font-weight:700>)</span><span style=color:#000;font-weight:700>.</span> 
</code></pre></div><p>meaning that <code>disney</code> entails that <code>goofy</code> is a dog <strong>and</strong> <code>mickey</code> is a mouse. If you squint, <code>:-</code> kinda looks like the turnstile <strong>( $\vdash$ )</strong> symbol. Note also that commas denote <strong>conjunction</strong> like they often do in mathematical notation.</p><p>Goofy and Mickey can be replaced by variables as such:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-prolog data-lang=prolog><span style=color:#000>disney</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>X</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>Y</span><span style=color:#000;font-weight:700>)</span> <span style=color:#000;font-weight:700>:-</span> <span style=color:#000>dog</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>X</span><span style=color:#000;font-weight:700>)</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>mouse</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>Y</span><span style=color:#000;font-weight:700>)</span><span style=color:#000;font-weight:700>.</span>
<span style=color:#000>disney</span><span style=color:#000;font-weight:700>(</span><span style=color:#4e9a06>goofy</span><span style=color:#000;font-weight:700>,</span> <span style=color:#4e9a06>mickey</span><span style=color:#000;font-weight:700>)</span><span style=color:#000;font-weight:700>.</span> 
</code></pre></div><p>These programs are equivalent, i.e., they yield the same facts. If you squint again, the rule now kinda looks like a function with the left hand side being the function header and the righthand side being the body. <em>This is not really a coincidence</em>.</p><h2 id=curry-howard-lambek-correspondence>Curry-Howard-Lambek correspondence</h2><p>It turns out that logic, lambda calculus, and turing machines are equivalent in terms of <em>what they can do</em><sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>. This is interesting in many ways. With this in mind, you could think of the different paradigms as simply <em>your choice of programming style</em>.</p><p><img src=/blog/images/so_what.webp alt="So what?"></p><p>In the programming language <a href=https://www.idris-lang.org/><strong>Idris</strong></a>, the same program can be interpreted both as a term in the lambda calculus and as a logical proposition. Since type systems are based on logic, this means that the same language can be used to talk about types and runtime behaviour. This allows for very advanced types to be defined, giving detailed guarantees about a programs <em>runtime behaviour</em> based on the programs type. <strong>Idris</strong> places a lot of emphasis on using <strong>total functions</strong>, since allowing anything else would lead to unsound behaviour when viewing terms as logic propositions.</p><p>There is much beauty to be found in the Curry-Howard-Lambek correspondence and its many implications, but the software industry doesn't care about beauty in general. It is notoriously difficult to quantify productivity gains from even the most basic type system, and this leads to an ongoing discussion on whether or not dynamic or static typing is &ldquo;<em>better</em>".</p><p><strong>Google</strong> released an article<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup> comparing the productivity and performance of <code>C++</code>, <code>Java</code>, <code>Go</code>, and <code>Scala</code>, however, making conclusions based on different people's solutions with different programming languages always seems to border on the philosophical. This is mainly true because it's not possible to remove the human factor &ndash; once I have experience with a specific problem, solving it again in another language would give that language an unfair advantage. In other words:</p><blockquote><p>there is no way to separate the <strong>programming discipline</strong> from the <strong>problem solving discipline</strong>.</p></blockquote><h1 id=a-few-words-about-pragmatism>A few words about pragmatism</h1><p>There are many languages that are less interested in having a close connection to a mathematical foundation, but instead adhere to the paradigm of the machines on which it will be run. Assembly languages are extremely pragmatic programming languages that are created with the purpose of controlling the CPU with a list of instructions. The vocabulary here is closely related to the CPU instructions and architecture on which it will be used. While this closely resembles <code>imperative programming</code>, there is little to no effort made to resemble the <code>Turing Machine</code>. While processors are indeed equivalent to the Turing Machine in terms of what it can calculate, there are a plethora of concepts invented to <em>speed up the processor</em> that bleed into the syntax and semantics of assembly languages.</p><p>This approach is much more pragmatic, and it has historically enabled extremely efficient use of the computing hardware. However, programs written in this style are inherently of a low level of abstraction. This means that programs can be difficult to understand, since the intention of the author is completely lost between a list of register-manipulating instructions.
Because of this, a number of <em>&ldquo;high level languages&rdquo;</em> were invented, allowing the use of more human-readable language, named variables, methods, and later - even recursion.</p><p>As programs grew in scope and complexity, maintaining and developing software became increasingly difficult. A need for <code>modularisation</code> slowly appeared. How can we make sure that changing our program doesn't incur <em>unwanted side effects</em>? How do make clear borders between <em>&ldquo;sections of our programs&rdquo;</em>, such that the interaction with software doesn't entail a complete understanding of the inner workings of that software?</p><p>One answer to this problem was &ldquo;objects&rdquo;. As I am writing this, I realize that giving a complete history of object oriented programming is out of scope, so I will cut it down to simply:</p><blockquote><p>Object oriented programming is one of the most successful approaches to modularity in the software industry to this date.</p></blockquote><h2 id=are-modules-part-of-the-paradigm>Are modules part of the paradigm?</h2><p>I would separate the <em>paradigm of computation</em> from the <em>paradigm of modularization</em>. The distinction of different &ldquo;categories&rdquo; of paradigms is often left to interpretation. I would suggest a few different categories like:</p><ul><li>Computational (what's the underlying model for computation, e.g. functional, logic, imperative,&mldr;)</li><li>Organizational (how are modules organized, e.g. files, packages, classes, objects, structs, &mldr;)</li><li>Methodology (abstract vs. non abstract, e.g. declarative vs imperative)</li></ul><p>You could add an arbitrary amount of categories to this list, but I feel like at least these 3 are useful. In the next few blog posts, I will concentrate on how the different <em>organizational</em> constructs in <em>Scala</em> solve programming challenges.</p><h2 id=solid-principle>SOLID principle</h2><blockquote><p>Note: I am not a fan of Robert C. Martin, and he is one of the few people I have blocked on Twitter. However, I realize that his work has inspired many and that SOLID is accepted as gospel to many, hence this section.</p></blockquote><p>The main design principles of object oriented programming according to the <em>SOLID principle</em><sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup> are:</p><ol><li>Single responsibility</li><li>Open-closed</li><li>Liskov substitution</li><li>Interface segregation</li><li>Dependency inversion</li></ol><p>I want to mainly discuss the 4th point. <strong>Interface segregation</strong> is closely related to <strong>single responsibility</strong> in trying to increase the focus of modules in your software. The less information and surface your interfaces have, the less likely it is that changing a module results in needing to update unrelated code. As a software engineer, I find that writing modules to a pragmatic size while still having small focused modules is difficult.</p><p>In a mixed paradigm language like Scala, we have many different ways to express modules:</p><ol><li>packages</li><li>mixin-traits</li><li>classes</li><li>case classes</li><li>sealed trait ADTs</li><li>objects (singletons)</li><li>function literals</li><li>typeclasses</li></ol><p>How on earth do we choose the right language feature for the right problem? What even constitutes a &ldquo;right&rdquo; choice?</p><h1 id=testing>Testing</h1><p><img src=/blog/images/testing.webp alt="Testing battery on tongue"></p><p>Most often, I find that writing tests for my code is a great way to quantify the modularity of the code. How easy is it to isolate the functions that I want to test? How much boiler plate do I need to set up my test cases? Can I run my tests in parallel? Do I need &ldquo;<strong>hacks</strong>&rdquo; to inspect the internals of the modules that I'm testing?</p><h2 id=testing-functional-programs>Testing functional programs</h2><p>Supposedly, functional programming <strong>is the best thing ever</strong> because it makes testing embarrassingly easy &ndash; this is not true in the general case! It's easy to write a purely functional program with a completely tangled up structure, where testing a single function effectively means testing the entire program. Heck, nothing stops you from writing your entire program <strong>as a single function</strong>.</p><p>Some problems also lend themselves beautifully to a functional programming solution, while others require ingenuity to be testable in a functional setting.</p><h3 id=testing-inherently-immutable-code>Testing inherently immutable code</h3><p>Say we need to test a function that sums up a list of integers. We could implement it like so:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=color:#204a87;font-weight:700>def</span> <span style=color:#000>sum</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>xs</span><span style=color:#204a87;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>List</span><span style=color:#ce5c00;font-weight:700>[</span><span style=color:#204a87;font-weight:700>Int</span><span style=color:#ce5c00;font-weight:700>]</span><span style=color:#ce5c00;font-weight:700>)</span><span style=color:#204a87;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>Int</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>xs</span> <span style=color:#204a87;font-weight:700>match</span> <span style=color:#ce5c00;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>case</span> <span style=color:#000>head</span> <span style=color:#204a87;font-weight:700>:</span><span style=color:#204a87;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>tail</span> <span style=color:#ce5c00;font-weight:700>=&gt;</span> <span style=color:#000>head</span> <span style=color:#ce5c00;font-weight:700>+</span> <span style=color:#000>sum</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>tail</span><span style=color:#ce5c00;font-weight:700>)</span>
  <span style=color:#204a87;font-weight:700>case</span> <span style=color:#000>Nil</span>          <span style=color:#204a87;font-weight:700>=&gt;</span> <span style=color:#0000cf;font-weight:700>0</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>testing it would amount to something like:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=color:#000>assert</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>sum</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>List</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#ce5c00;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>2</span><span style=color:#ce5c00;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>3</span><span style=color:#ce5c00;font-weight:700>)</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>==</span> <span style=color:#0000cf;font-weight:700>6</span><span style=color:#ce5c00;font-weight:700>)</span>
</code></pre></div><p>This is nice. This is simple. But why is it simple? If we see <code>sum</code> as a module, it deals only with the argument of interest (<code>xs</code>), and it produces only 1 result, which is the interesting result for summing up a list. There is no <strong>overfetching</strong> of arguments, and there is no <strong>overproducing</strong> of results or side effects. But the real life happens, and you need to do much much more than adding numbers:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=color:#204a87;font-weight:700>case</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>S3Conf</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>user</span><span style=color:#204a87;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>String</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>secret</span><span style=color:#204a87;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>String</span><span style=color:#ce5c00;font-weight:700>)</span>

<span style=color:#204a87;font-weight:700>case</span> <span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>AppConf</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>baseUrl</span><span style=color:#204a87;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>String</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>databaseUrl</span><span style=color:#204a87;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>String</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>port</span><span style=color:#204a87;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>Int</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>s3Conf</span><span style=color:#204a87;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>S3Conf</span><span style=color:#ce5c00;font-weight:700>)</span>

<span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>BusinessDatabase</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>appConf</span><span style=color:#204a87;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>AppConf</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>db</span><span style=color:#204a87;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>DatabaseApi</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>logger</span><span style=color:#204a87;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>Logger</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>{</span>

  <span style=color:#204a87;font-weight:700>def</span> <span style=color:#000>insertBusinessObject</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>obj</span><span style=color:#204a87;font-weight:700>:</span><span style=color:#204a87;font-weight:700>Object</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#204a87;font-weight:700>=</span> <span style=color:#000>db</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#000>insert</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>obj</span><span style=color:#ce5c00;font-weight:700>)</span>

  <span style=color:#204a87;font-weight:700>def</span> <span style=color:#000>removeObject</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>id</span><span style=color:#204a87;font-weight:700>:</span><span style=color:#204a87;font-weight:700>ObjectId</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#204a87;font-weight:700>=</span> <span style=color:#000>db</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#000>remove</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#000>id</span><span style=color:#ce5c00;font-weight:700>)</span>

  <span style=color:#204a87;font-weight:700>def</span> <span style=color:#000>listObjects</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#204a87;font-weight:700>=</span> <span style=color:#ce5c00;font-weight:700>{</span>
    <span style=color:#000>logger</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#000>debug</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#4e9a06>s&#34;</span><span style=color:#4e9a06>Listing all objects for database url: </span><span style=color:#4e9a06>${</span><span style=color:#000>appConf</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#000>databaseUrl</span><span style=color:#4e9a06>}</span><span style=color:#4e9a06>&#34;</span><span style=color:#ce5c00;font-weight:700>)</span>
    <span style=color:#000>db</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#000>listAll</span><span style=color:#ce5c00;font-weight:700>(</span><span style=color:#ce5c00;font-weight:700>)</span>
  <span style=color:#ce5c00;font-weight:700>}</span>

  <span style=color:#ce5c00;font-weight:700>.</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#ce5c00;font-weight:700>.</span>
<span style=color:#ce5c00;font-weight:700>}</span>
</code></pre></div><p>Now, our main module here is <code>BusinessDatabase</code>. It has some dependencies on <code>AppConf</code>, <code>DatabaseApi</code>, and <code>Logger</code>. We see that it implements 3 functions, each doing <em>something</em> with the database API. In that sense, it makes much sense that they exist within the same class. <code>listObjects</code>, however, is the only method that makes use of <code>appConf</code> and <code>logger</code>. Testing <code>insertBusinessObject</code> now entails the construction of both an <code>AppConf</code> and a <code>Logger</code>, even though we don't really need them. How do we solve this? We could extract the &ldquo;culprit&rdquo;, <code>listObjects</code>, such that we could get rid of the 2 arguments for this class, but there's a good chance that we would add a new debug-log in another function down the line. Naming would also be an issue, as there's no real (=business) reason for this extraction other than testing/modularity. So we just leave this imperfection in our code üòØ?</p><p><img src=/blog/images/not_good_enough.webp alt="Not good enough"></p><p>It doesn't really leave us with much in terms of professional satisfaction.</p><h1 id=the-blog>The blog</h1><p>In the next few posts, I want to investigate how modularity is solved with different approaches like <code>classes and interfaces</code>, <code>typeclasses</code>, <code>final tagless</code>, and <code>free monads</code>.</p><p>Does one approach lead to smaller modules? What's the weight in terms of boiler plate? What kind of background and understanding is needed for each approach? How do our tests change based on the different approaches? I don't have all the answers yet, but I'm looking forward to aligning my thoughts on modularity and functional programming.</p><p>See you in the next post üëãüèª</p><p><img src=/blog/images/see_you.webp alt="See you"></p><section class=footnotes role=doc-endnotes><hr><ol><li id=fn:1 role=doc-endnote><p><a href=https://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence>Curry-Howard Correspondence on Wikipedia</a> <a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2 role=doc-endnote><p><a href=https://days2011.scala-lang.org/sites/days2011/files/ws3-1-Hundt.pdf>Loop Recognition in C++/Java/Go/Scala</a>, Robert Hundt, Scala Days 2011. <a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3 role=doc-endnote><p><a href=https://en.wikipedia.org/wiki/SOLID>SOLID principle on Wikipedia</a> <a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></section></article><ul class="pager blog-pager"></ul></div></div></div><footer><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><ul class="list-inline text-center footer-links"><li><a href=https://github.com/hejfelix title=GitHub><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i><i class="fab fa-github fa-stack-1x fa-inverse"></i></span></a></li><li><a href=https://twitter.com/FelixHargreaves title=Twitter><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i><i class="fab fa-twitter fa-stack-1x fa-inverse"></i></span></a></li><li><a href=https://linkedin.com/in/felix-hargreaves-9b0b3035 title=LinkedIn><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i><i class="fab fa-linkedin fa-stack-1x fa-inverse"></i></span></a></li><li><a href=https://stackoverflow.com/users/238100/felix title=StackOverflow><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i><i class="fab fa-stack-overflow fa-stack-1x fa-inverse"></i></span></a></li></ul><p class="credits copyright text-muted">Felix Bj√¶rt Hargreaves
&nbsp;&bull;&nbsp;&copy;
2020
&nbsp;&bull;&nbsp;
<a href=https://hejfelix.github.io/blog/>Felix' Programming Blog</a></p><p class="credits theme-by text-muted"><a href=https://gohugo.io>Hugo v0.61.0</a> powered &nbsp;&bull;&nbsp; Theme <a href=https://github.com/halogenica/beautifulhugo>Beautiful Hugo</a> adapted from <a href=https://deanattali.com/beautiful-jekyll/>Beautiful Jekyll</a></p></div></div></div></footer><script src=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.js integrity=sha384-K3vbOmF2BtaVai+Qk37uypf7VrgBubhQreNQe9aGsz9lB63dIFiQVlJbr92dw2Lx crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/contrib/auto-render.min.js integrity=sha384-kmZOZB5ObwgQnS/DuDg6TScgOiWWBiVt0plIRkZCmE6rDZGrEOQeHM5PcHi+nyqe crossorigin=anonymous></script><script src=https://code.jquery.com/jquery-1.12.4.min.js integrity="sha256-ZosEbRLbNQzLpnKIkEdrPv7lOy9C27hHQ+Xp8a4MxAQ=" crossorigin=anonymous></script><script src=https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js integrity=sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa crossorigin=anonymous></script><script src=https://hejfelix.github.io/blog/js/main.js></script><script>renderMathInElement(document.body);</script><script src=https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe.min.js integrity=sha384-QELNnmcmU8IR9ZAykt67vGr9/rZJdHbiWi64V88fCPaOohUlHCqUD/unNN0BXSqy crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe-ui-default.min.js integrity=sha384-m67o7SkQ1ALzKZIFh4CiTA8tmadaujiTa9Vu+nqPSwDOqHrDmxLezTdFln8077+q crossorigin=anonymous></script><script src=https://hejfelix.github.io/blog/js/load-photoswipe.js></script></body></html>